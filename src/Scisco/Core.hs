module Scisco.Core where

import           Control.Concurrent
import           Control.Lens
import qualified Crypto.Hash                as C
import qualified Crypto.PubKey.ECC.ECDSA    as C
import qualified Crypto.PubKey.ECC.Generate as C
import qualified Data.Aeson                 as A
import qualified Data.Binary                as B
import qualified Data.ByteString.Char8      as B
import qualified Data.ByteString.Lazy       as BL
import qualified Data.HashMap.Strict        as M
import qualified Data.Text                  as T
import           Foundation
import qualified Prelude

import           Proto.Types
import qualified Scisco.Consensus           as Consensus
import qualified Scisco.LRS                 as LRS
import           Scisco.Types

handle ∷ MVar State → Request → IO Response
handle state request = do

  let handleCase ∷ ∀ a . (Request → Maybe a) → (a → IO Response) → IO Response → IO Response
      handleCase getter func cont =
        case getter request of
          Just x  → func x
          Nothing → cont

      respondWith func handler = fmap (\val → func .~ val $ emptyResponse) . handler

  -- This is clumsy but concise; the autogenerated data structure is odd to handle (usually would be a sum type).
  handleCase _Request'info (respondWith info (handleInfo state)) $ do
    handleCase _Request'echo (respondWith echo handleEcho) $ do
      handleCase _Request'flush (respondWith flush handleFlush) $ do
        handleCase _Request'setOption (respondWith setOption handleOption) $ do
          handleCase _Request'initChain (respondWith initChain handleInitChain) $ do
            handleCase _Request'checkTx (respondWith checkTx (handleCheckTx state)) $ do
              handleCase _Request'beginBlock (respondWith beginBlock handleBeginBlock) $ do
                handleCase _Request'deliverTx (respondWith deliverTx (handleDeliverTx state)) $ do
                  handleCase _Request'endBlock (respondWith endBlock handleEndBlock) $ do
                    handleCase _Request'commit (respondWith commit (handleCommit state)) $ do
                      handleCase _Request'query (respondWith query (handleQuery state)) $ do
                        return $ exception .~ ResponseException unknown $ emptyResponse

load ∷ IO (MVar State)
load = do
  -- TODO Implement actual state serialization. Not necessary for demonstration purposes.
  state ← return $ State 0 M.empty
  newMVar state

handleQuery ∷ MVar State → RequestQuery → IO ResponseQuery
handleQuery state (RequestQuery dta path height _) =
  case T.split ((==) '/') path of
    ["state", "elections"] → do
      state ← readMVar state
      return $ ResponseQuery OK 0 B.empty (BL.toStrict $ A.encode $ M.keys $ stateElections state) B.empty (fromIntegral $ stateLastBlockHeight state) T.empty
    ["state", "elections", name] → do
      state ← readMVar state
      case M.lookup name $ stateElections state of
        Just e  → do
          return $ ResponseQuery OK 0 B.empty (BL.toStrict $ A.encode e) B.empty (fromIntegral $ stateLastBlockHeight state) T.empty
        Nothing → return $ ResponseQuery InternalError 0 B.empty B.empty B.empty 0 T.empty
    ["p2p", "filter", "pubkey", _]  → return $ ResponseQuery OK 0 B.empty B.empty B.empty height T.empty
    ["p2p", "filter", "addr", _]    → return $ ResponseQuery OK 0 B.empty B.empty B.empty height T.empty

    -- Not really "state" queries; these could be moved into a separate server (or done client-side), but convenient for now.

    ["aux", "ecc", "keys", "generate"] → do
      state ← readMVar state
      (C.PublicKey _ pub, C.PrivateKey _ pri) ← C.generate curve
      return $ ResponseQuery OK 0 B.empty (BL.toStrict $ A.encode (pub, pri)) B.empty (fromIntegral $ stateLastBlockHeight state) T.empty

    ["aux", "lrs", "keys", "generate"] → do
      state ← readMVar state
      keypair ← LRS.genKeypair
      return $ ResponseQuery OK 0 B.empty (BL.toStrict $ A.encode keypair) B.empty (fromIntegral $ stateLastBlockHeight state) T.empty
    ["aux", "lrs", "votes", "sign"] → do
      case A.decodeStrict dta of
        Just (ring, keypair, election, candidatePubKey) → do
          state ← readMVar state
          sig ← LRS.sign ring keypair $ BL.toStrict $ B.encode (election ∷ T.Text, "castVote" ∷ B.ByteString, candidatePubKey ∷ C.PublicPoint)
          return $ ResponseQuery OK 0 B.empty (BL.toStrict $ A.encode sig) B.empty (fromIntegral $ stateLastBlockHeight state) T.empty
        Nothing ->
          return $ ResponseQuery EncodingError 0 B.empty B.empty B.empty 0 T.empty
    _                               → return $ ResponseQuery UnknownRequest 0 B.empty B.empty B.empty 0 unknown

handleInfo ∷ MVar State → RequestInfo → IO ResponseInfo
handleInfo state RequestInfo = do
  state ← readMVar state
  return $ ResponseInfo {
    _ResponseInfo'data'             = "/scisco-alpha/",
    _ResponseInfo'version           = "0.1.0.0",
    _ResponseInfo'lastBlockHeight   = fromIntegral $ stateLastBlockHeight state,
    _ResponseInfo'lastBlockAppHash  = B.empty
  }

handleEcho ∷ RequestEcho → IO ResponseEcho
handleEcho (RequestEcho e) = return $ ResponseEcho e

handleFlush ∷ RequestFlush → IO ResponseFlush
handleFlush RequestFlush = return ResponseFlush

handleOption ∷ RequestSetOption → IO ResponseSetOption
handleOption _ = return $ ResponseSetOption "ok"

handleInitChain ∷ RequestInitChain → IO ResponseInitChain
handleInitChain _ = return ResponseInitChain

handleBeginBlock ∷ RequestBeginBlock → IO ResponseBeginBlock
handleBeginBlock _ = return ResponseBeginBlock

handleDeliverTx ∷ MVar State → RequestDeliverTx → IO ResponseDeliverTx
handleDeliverTx state (RequestDeliverTx tx) = do
  case A.decodeStrict tx of
    Nothing ->
      return $ ResponseDeliverTx EncodingError B.empty undecodable
    Just tx → do
      modifyMVar state $ \state → do
        case Consensus.apply state tx of
          Right updated → return (updated, ResponseDeliverTx OK B.empty T.empty)
          Left err      → return (state,   ResponseDeliverTx BadNonce B.empty $ "consensus_violation - " `T.append` (T.pack $ Prelude.show err))

handleCheckTx ∷ MVar State → RequestCheckTx → IO ResponseCheckTx
handleCheckTx state (RequestCheckTx tx) = do
  case A.decodeStrict tx of
    Nothing ->
      return $ ResponseCheckTx EncodingError B.empty undecodable
    Just tx → do
      modifyMVar state $ \state → do
        case Consensus.apply state tx of
          Right _   → return (state, ResponseCheckTx OK B.empty T.empty)
          Left err  → return (state, ResponseCheckTx BadNonce B.empty $ "consensus_violation - " `T.append` (T.pack $ Prelude.show err))

handleEndBlock ∷ RequestEndBlock → IO ResponseEndBlock
handleEndBlock _ = return $ ResponseEndBlock []

handleCommit ∷ MVar State → RequestCommit → IO ResponseCommit
handleCommit state _ = do
  state ← readMVar state
  return $ ResponseCommit OK (sha256 $ BL.toStrict $ B.encode state) T.empty

sha256 ∷ B.ByteString → B.ByteString
sha256 str = B.pack $ Prelude.show (C.hash str ∷ C.Digest C.SHA3_256)

emptyResponse ∷ Response
emptyResponse = Response Nothing Nothing Nothing Nothing Nothing Nothing Nothing Nothing Nothing Nothing Nothing Nothing

unknown ∷ T.Text
unknown = "unknown_request"

undecodable ∷ T.Text
undecodable = "undecodable"
